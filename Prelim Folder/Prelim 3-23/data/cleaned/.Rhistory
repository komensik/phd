generate_q4_base_codebook <- function(raw_data) {
q4_binary_cols <- names(raw_data)[str_detect(names(raw_data), "^Q4_\\d+_\\d+$")]
tibble(variable_name = q4_binary_cols) %>%
mutate(
statement_number = str_extract(variable_name, "(?<=Q4_)\\d+(?=_)"),
response_option_code = str_extract(variable_name, "(?<=_)\\d+$"),
response_option = case_when(
response_option_code == "1" ~ "You",
response_option_code == "2" ~ "Someone you know well",
response_option_code == "3" ~ "No/Don't know",
TRUE ~ NA_character_
),
type = "Binary (0/1)",
values = "1 = selected, 0 = not selected, NA = no response",
notes = "From Q4 matrix question (multiple selection possible)"
)
}
#| include: false
#view(raw_data)
# DeservingPower Blocks
#FL_8_DO_Deserving&PowerBlockA %in% names(raw_data)
# Add participant block variable (group a, b, c)
raw_data <- raw_data %>%
mutate(
block = case_when(
!is.na(`fl_8_do_deserving_power_block_a`) ~ "A",
!is.na(`fl_8_do_deserving_power_block_b`) ~ "B",
!is.na(`fl_8_do_deserving_power_block_c`) ~ "C",
TRUE ~ NA_character_
)
)
# Save labeled but otherwise unmodified version
write_csv(raw_data, "./data/cleaned/labeled_raw_data.csv")
#| include: false
#summary(raw_data)
columns_to_drop <- c(
"status", "start_date", "end_date", "ip_address", "recipient_last_name", "recipient_first_name",
"recipient_email", "external_reference", "recorded_date", "location_latitude",
"location_longitude", "distribution_channel", "user_language"
)
names(raw_data)
# Drop all columns containing "_DO" (Display Order)
do_columns <- grep("_do", names(raw_data), value = TRUE)
# Drop everything
raw_data_cleaned <- raw_data %>%
select(-all_of(c(columns_to_drop, do_columns)))
# Check
length(do_columns)
#| eval: false
#| include: false
# Filter to those who consented
raw_data_cleaned <- raw_data_cleaned %>%
filter(consent == 1)
# Save again
write_csv(raw_data_cleaned, "data/cleaned/cleaned_data_consent.csv")
#remove consent col
raw_data_cleaned <- raw_data_cleaned %>%
select(-consent)
#| eval: false
#| include: false
# 1. create logical variable (true/false) that marks whether respondent answered Q9 with 4
attn_check_q9 <- raw_data_cleaned$q9 == 4
#2. attention flag - tae text responses to Q17, remove leading/trailing spaces, and convert everything to lowercase for standardization)
attn_text <- tolower(str_trim(raw_data_cleaned$q17))
#2a. create list of acceptable answers for Q17
accepted_variants <- c("purple", "\"purple\"", "purpke", "purplee", "prurprle", "purpl", "purp", "üíú", "üü£")
#2b. chheck if each cleaned Q17 response is in thhe list of accepted variants. if yes, respondent passed attn check
attn_check_q17 <- attn_text %in% accepted_variants
#3. attn flag -- Create a flag for whether the respondent answered Q114_4 with a 6 (i.e., passed the third attention check
attn_check_q1114 <- raw_data_cleaned$q114_4 == 6
#If Q114_4 equals -99 (an invalid code), treat that as a failed check.
attn_check_q1114[raw_data_cleaned$q114_4 == -99] <- FALSE
#If Q114_4 is NA (they didn‚Äôt see the question), count that as a pass because they weren‚Äôt shown the question
attn_check_q1114[is.na(raw_data_cleaned$q114_4)] <- TRUE  # not shown ‚Üí pass
# 2. Create score + filter full failures
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
attn_q9_pass = attn_check_q9,
attn_q17_pass = attn_check_q17,
attn_q1114_pass = attn_check_q1114,
attn_pass_count = as.integer(attn_q9_pass) + as.integer(attn_q17_pass) + as.integer(attn_q1114_pass)
) %>%
filter(attn_pass_count > 0)  # Remove only people who failed all
#| eval: false
#| include: false
raw_data_cleaned <- raw_data_cleaned %>%
mutate(duration_in_seconds = as.numeric(duration_in_seconds))
str(raw_data_cleaned$duration_in_seconds)
raw_data_cleaned$duration_sec <- as.numeric(raw_data_cleaned$duration_in_seconds)
raw_data_cleaned <- raw_data_cleaned %>%
filter(duration_in_seconds >= 480)
#| eval: false
#| include: false
mapping <- read_csv("./data/Unified_Deserving_Power_Target_Mapping.csv")
#| eval: false
#| include: false
# Identify all Deserving and Power columns
deserving_power_cols <- names(raw_data_cleaned)[str_detect(names(raw_data_cleaned), "^(Deserving|Power) Group")]
raw_data_cleaned <- raw_data_cleaned %>%
mutate(across(
all_of(deserving_power_cols),
as.character
))
raw_data_cleaned <- raw_data_cleaned %>%
mutate(across(
all_of(deserving_power_cols),
~ as.numeric(na_if(.x, "-99"))
))
table(raw_data_cleaned$`Deserving Group A_1`, useNA = "always")
#| eval: false
#| include: false
#new_vars <- c(
#  "d_black_afam_abc", "d_native_ind_abc", "d_asianam_abc", "d_latino_his_abc", "d_whiteam_abc",
#  "d_mideastam_abc", "d_incwomen_abc", "d_collegewom_abc", "d_enviro_abc", "d_feminists_abc",
#  "d_proabort_choice_abc", "d_abortprov_abc", "d_welfare_tanf_abc", "d_fstamps_snap_abc",
#  "d_unions_abc", "d_medicaid_abc", "d_medicare_abc", "d_unemployed_abc", "d_police_abc",
#  "d_poorfam_abc", "d_wealthy_abc", "d_teachers_abc", "d_sci_experts_abc", "d_child_abc",
#  "d_crim_abc", "d_incppl_abc", "d_homeless_abc", "d_immigrants_abc", "d_unauth_undoc_abc",
#  "d_gunowners_abc", "d_voters_abc", "d_lgbt_abc", "d_trans_abc", "d_transkids_abc", "d_gunmans_abc",
#  "d_ice_abc", "d_socmed_abc", "d_nra_abc", "d_bigbank_abc", "d_bigcorp_abc", "d_uni_abc",
#  "d_comcoll_abc", "d_noncit_parent_a", "d_incparents_a", "d_hsteen_a", "d_athiest_a", "d_cath_a",
#  "d_evan_a", "d_jews_a", "d_pal_a", "d_muslim_a", "d_blackwom_a", "d_blackmen_a", "d_lds_a",
#  "d_longcov_a", "d_exon_a", "d_weed_a", "d_opioid_a", "d_whitecol_a", "d_tech_a", "d_smokers_a",
#  "d_genx_a", "d_boomer_a", "d_mill_a", "d_genz_a"
#)
#
#for (var in new_vars) {
#  raw_data_cleaned[[var]] <- NA #to initialize
#}
library(readxl)
library(stringr)
library(dplyr)
# Load the mapping
mapping <- read_excel("scratch for consolidation.xlsx")
view(mapping)
# Clean column names and values in mapping to match raw_data_cleaned
mapping <- mapping %>%
rename(
var_a = `Deserving Group A`,
var_b = `Deserving Group B`,
var_c = `Deserving Group C`
) %>%
mutate(
var_a = str_replace_all(tolower(trimws(var_a)), " ", "_"),
var_b = str_replace_all(tolower(trimws(var_b)), " ", "_"),
var_c = str_replace_all(tolower(trimws(var_c)), " ", "_")
)
# Create consolidated variables
for (i in 1:nrow(mapping)) {
new_var <- mapping$target_slug[i]
var_a <- mapping$var_a[i]
var_b <- mapping$var_b[i]
var_c <- mapping$var_c[i]
# Optional check
if (!all(c(var_a, var_b, var_c) %in% names(raw_data_cleaned))) {
warning(paste("Missing column(s) for:", new_var))
}
raw_data_cleaned[[new_var]] <- dplyr::case_when(
raw_data_cleaned$block == "A" ~ as.numeric(raw_data_cleaned[[var_a]]),
raw_data_cleaned$block == "B" ~ as.numeric(raw_data_cleaned[[var_b]]),
raw_data_cleaned$block == "C" ~ as.numeric(raw_data_cleaned[[var_c]]),
TRUE ~ NA_real_
)
}
#verify:
raw_data_cleaned %>%
select(block, deserving_group_a_26, d_incppl_pris_abc) %>%
filter(block == "A") %>%
slice(1:10)
#| eval: false
#| include: false
# Load the spreadsheet with the mappings
library(readxl)
mapping <- read_excel("scratch for consolidation.xlsx")
#CHECKING
#view(mapping)
#view(raw_data_cleaned)
#colnames(raw_data_cleaned)
#clean mapping col names to match raw_data_cleaned
mapping <- mapping %>%
mutate(
`Deserving Group A` = str_replace_all(tolower(trimws(`Deserving Group A`)), " ", "_"),
`Deserving Group B` = str_replace_all(tolower(trimws(`Deserving Group B`)), " ", "_"),
`Deserving Group C` = str_replace_all(tolower(trimws(`Deserving Group C`)), " ", "_")
)
#preview mapping to confirm fix
mapping %>%
select(target_slug, `Deserving Group A`, `Deserving Group B`, `Deserving Group C`) %>%
head(10)
print(
mapping %>%
select(target_slug, `Deserving Group A`, `Deserving Group B`, `Deserving Group C`) %>%
head(10)
)
dim(mapping)  # shows number of rows and columns
print(mapping)
names(mapping)
# Create composite deservingness variables from the correct block column only
for (i in 1:nrow(mapping)) {
new_var <- mapping$target_slug[i]
var_a <- mapping$`Deserving Group A`[i]
var_b <- mapping$`Deserving Group B`[i]
var_c <- mapping$`Deserving Group C`[i]
raw_data_cleaned[[new_var]] <- case_when(
raw_data_cleaned$block == "A" ~ raw_data_cleaned[[var_a]],
raw_data_cleaned$block == "B" ~ raw_data_cleaned[[var_b]],
raw_data_cleaned$block == "C" ~ raw_data_cleaned[[var_c]],
TRUE ~ NA_real_
)
}
view(raw_data_cleaned)
#| eval: false
#| include: false
# Load the split mapping
split_map <- read.csv("./data/deserving_split.csv")
# Clean and normalize names to match raw_data_cleaned
split_map <- split_map %>%
rename(old_var = `var.name`, new_var = target_slug) %>%
mutate(
old_var = str_replace_all(tolower(trimws(old_var)), " ", "_"),
new_var = trimws(new_var)
)
skipped <- list()
for (i in 1:nrow(split_map)) {
old_var <- split_map$old_var[i]
new_var <- split_map$new_var[i]
# Only proceed if old_var is in dataset
if (!(old_var %in% names(raw_data_cleaned))) {
skipped[[new_var]] <- paste("Missing column:", old_var)
next
}
# Check if there is *any valid data* (not -99)
non_missing <- raw_data_cleaned[[old_var]] != -99 & !is.na(raw_data_cleaned[[old_var]])
if (!any(non_missing, na.rm = TRUE)) {
skipped[[new_var]] <- paste("No valid data in", old_var)
next
}
# If we get here: create the new variable
raw_data_cleaned[[new_var]] <- raw_data_cleaned[[old_var]]
}
if (length(skipped) > 0) {
print("‚ö†Ô∏è Skipped variables:")
print(skipped)
} else {
print("‚úÖ All group-specific variables renamed successfully.")
}
names(raw_data_cleaned)
# OLD
# Loop through and rename each variable
#for (i in 1:nrow(split_map)) {
#  old_var <- split_map$var.name[i]     # e.g., "Deserving Group A_43"
#  new_var <- split_map$target_slug[i]  # e.g., "d_noncit_parent_a"
# Just copy the values over
#  raw_data_cleaned[[new_var]] <- raw_data_cleaned[[old_var]]
#}
# Combine both sets of variables to clean
vars_to_clean <- c(mapping$target_slug, split_map$new_var)
# Only keep variables that exist in the dataset
vars_to_clean <- vars_to_clean[vars_to_clean %in% names(raw_data_cleaned)]
# Recode -99 to NA
raw_data_cleaned <- raw_data_cleaned %>%
mutate(across(all_of(vars_to_clean), ~ {
if (is.character(.x)) {
na_if(.x, "-99")  # character version
} else if (is.numeric(.x)) {
na_if(.x, -99)    # numeric version
} else {
.x  # leave unchanged
}
}))
sapply(raw_data_cleaned[vars_to_clean], class)
#vector of old variable names
block_vars_to_drop <- grep("^(deserving_group|power_group)_[abc]_", names(raw_data_cleaned), value = TRUE)
#create version with them dropped
cleaned_data_light <- raw_data_cleaned %>%
select(-all_of(block_vars_to_drop))
view(cleaned_data_light)
write_csv(raw_data_cleaned, "data/cleaned/cleaned_data_consent.csv")
#light csv
write_csv(cleaned_data_light, "data/cleaned/cleaned_light.csv") # main file to use going forward
# Making "unique" combinations that include possible accidental "both incarcerated and none." I'm erring on the side of caution, given these are sensitive questions that might confuse participants. For example, someone might quickly check "myself," but then see "someone you know" followed by "don't know/unsure", and think the latter is in regards to knowing someone who has been incarcerated or victimized. I'll run the models with different versions."
contact_pattern = c(
"100000",  # Incarcerated Only
"100001",  # Incarcerated Only
"101001",  # Incarcerated Only
"101000",  # Incarcerated Only
"010000",  # Knows Inc Only
"010001",  # Knows Inc Only
"011001",  # Knows Inc Only
"011000",  # Knows Inc Only
"001100",  # Victim Only
"001101",  # Victim Only
"000100",  # Victim Only
"000101",  # Victim Only
"110000",  # Inc, Knows Inc
"110001",  # Inc, Knows Inc
"111001",  # Inc, Knows Inc
"111000",  # Inc, Knows Inc
"100100",  # Inc, Vict
"100101",  # Inc, Vict
"101100",  # Inc, Vict
"101101",  # Inc, Vict
"100010",  # Inc, Knows Vict
"101011",  # Inc, Knows Vict
"100011",  # Inc, Knows Vict
"101010",  # Inc, Knows Vict
"010100",  # Knows Inc, Vict
"010101",  # Knows Inc, Vict
"011101",  # Knows Inc, Vict
"011100",  # Knows Inc, Vict
"110100",  # Inc, Knows Inc, Vict
"110101",  # Inc, Knows Inc, Vict
"111101",  # Inc, Knows Inc, Vict
"010110",  # Knows Inc, Vict, Knows Vict
"011111",  # Knows Inc, Vict, Knows Vict
"011110",  # Knows Inc, Vict, Knows Vict
"010111",  # Knows Inc, Vict, Knows Vict
"110110",  # All
"111110",  # All
"110111",  # All
"111111",  # All
"011100"   # Also and only KI
),
knitr::opts_chunk$set(
echo = FALSE,       # Hide code by default
warning = FALSE,
message = FALSE
)
# Load packages
library(dplyr)
library(tidyr)
library(readr)
library(janitor)   # for clean_names()
library(tibble)
library(stringr)
library(haven)
library(tibble)
library(gt)
raw_data_cleaned <- readr::read_csv("data/cleaned/cleaned_light.csv") #note that althhough this is called raw_data_cleaned, it is the equivalent of "cleaned_data_light" from data_prep.qmd. See that file to pull the version with old var names for D andP. Note: no power here.
#names(raw_data_cleaned)
#| eval: false
#| include: false
# List of deserving control variables
deserving_control_vars <- c(
"d_welfare_tanf_abc", "d_fstamps_snap_abc", "d_medicaid_abc", "d_medicare_abc",
"d_unemployed_abc", "d_poorfam_abc", "d_homeless_abc", "d_immigrants_abc",
"d_unauth_undoc_abc", "d_trans_abc", "d_transkids_abc",
"d_noncit_parent_a", "d_unins_c", "d_mentill_c"
)
# Create composite deservingness control variable
raw_data_cleaned <- raw_data_cleaned %>%
mutate(desor = rowMeans(select(., all_of(deserving_control_vars)), na.rm = TRUE))
#view(raw_data_cleaned$Q4_1_1)
# Basic Totals
#I‚Äôm counting how many people said they themselves have been incarcerated by checking where Q4_1_1 equals 1. I‚Äôm ignoring missing values
total_incarcerated <- sum(raw_data_cleaned$q4_1_1 == 1, na.rm = TRUE)
#"I‚Äôm counting how many people said they know someone who‚Äôs been incarcerated (Q4_1_2 == 1). Again, I‚Äôm skipping over any missing answers."
total_knows_incarcerated <- sum(raw_data_cleaned$q4_1_2 == 1, na.rm = TRUE)
#I‚Äôm counting how many people selected ‚Äòno / unsure‚Äô when asked about incarceration experience (Q4_1_3 == 1)
total_no_incarcerated <- sum(raw_data_cleaned$q4_1_3 == 1, na.rm = TRUE)
#I‚Äôm counting how many respondents said they themselves were a victim of violent crime.
total_victim <- sum(raw_data_cleaned$q4_2_1 == 1, na.rm = TRUE)
#I‚Äôm counting how many said they know someone who was a victim of violent crime
total_knows_victim<- sum(raw_data_cleaned$q4_2_2 == 1, na.rm = TRUE)
#I‚Äôm counting those who selected ‚Äòno / unsure‚Äô for victimization experience
total_no_victim <- sum(raw_data_cleaned$q4_2_3 == 1, na.rm = TRUE)
#counting the total of those who said they were incarcerated, know incarcerated, or victims)
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
impact = if_else(
q4_1_1 == 1 | q4_1_2 == 1 | q4_2_1 == 1,
1, 0,
missing = NA_real_
)
)
#specific binary impact indicators
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
incarc = if_else(
q4_1_1 == 1,
1,
0,
missing = NA_real_
)
)
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
knowincarc = if_else(
q4_1_2 == 1,
1,
0,
missing = NA_real_
)
)
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
noincarc = if_else(
q4_1_1 == 0 | q4_1_2 == 0 | q4_1_3 == 1,
1, 0,
missing = NA_real_
)
)
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
vict = if_else(
q4_2_1 == 1,
1,
0,
missing = NA_real_
)
)
raw_data_cleaned <- raw_data_cleaned %>%
mutate(
contact_pattern = paste0(
coalesce(q4_1_1, 0),
coalesce(q4_1_2, 0),
coalesce(q4_1_3, 0),
coalesce(q4_2_1, 0),
coalesce(q4_2_2, 0),
coalesce(q4_2_3, 0)
)
)
count(raw_data_cleaned, contact_pattern)
#table(raw_data_cleaned$Q4_1_3, useNA = "always")
#table(raw_data_cleaned$Q4_2_3, useNA = "always")
strange1 <- raw_data_cleaned %>%
filter(q4_1_1 == 1 & q4_1_3 == 1)
strange2 <- raw_data_cleaned %>%
filter(q4_1_2 == 1 & q4_1_3 == 1)
strange3 <- raw_data_cleaned %>%
filter(q4_2_1 == 1 & q4_1_3 == 1)
strange4 <- raw_data_cleaned %>%
filter(q4_2_2 == 1 & q4_1_3 == 1)
print(strange1)
print(strange2)
print(strange3)
print(strange4)
#
count(contact_pattern)
# Making "unique" combinations that include possible accidental "both incarcerated and none." I'm erring on the side of caution, given these are sensitive questions that might confuse participants. For example, someone might quickly check "myself," but then see "someone you know" followed by "don't know/unsure", and think the latter is in regards to knowing someone who has been incarcerated or victimized. I'll run the models with different versions."
contact_pattern = c(
"100000",  # Incarcerated Only
"100001",  # Incarcerated Only
"101001",  # Incarcerated Only
"101000",  # Incarcerated Only
"010000",  # Knows Inc Only
"010001",  # Knows Inc Only
"011001",  # Knows Inc Only
"011000",  # Knows Inc Only
"001100",  # Victim Only
"001101",  # Victim Only
"000100",  # Victim Only
"000101",  # Victim Only
"110000",  # Inc, Knows Inc
"110001",  # Inc, Knows Inc
"111001",  # Inc, Knows Inc
"111000",  # Inc, Knows Inc
"100100",  # Inc, Vict
"100101",  # Inc, Vict
"101100",  # Inc, Vict
"101101",  # Inc, Vict
"100010",  # Inc, Knows Vict
"101011",  # Inc, Knows Vict
"100011",  # Inc, Knows Vict
"101010",  # Inc, Knows Vict
"010100",  # Knows Inc, Vict
"010101",  # Knows Inc, Vict
"011101",  # Knows Inc, Vict
"011100",  # Knows Inc, Vict
"110100",  # Inc, Knows Inc, Vict
"110101",  # Inc, Knows Inc, Vict
"111101",  # Inc, Knows Inc, Vict
"010110",  # Knows Inc, Vict, Knows Vict
"011111",  # Knows Inc, Vict, Knows Vict
"011110",  # Knows Inc, Vict, Knows Vict
"010111",  # Knows Inc, Vict, Knows Vict
"110110",  # All
"111110",  # All
"110111",  # All
"111111",  # All
"011100"   # Also and only KI
)
knitr::opts_chunk$set(
echo = FALSE,       # Hide code by default
warning = FALSE,
message = FALSE
)
# Load packages
library(dplyr)
library(tidyr)
library(readr)
library(janitor)   # for clean_names()
library(tibble)
library(stringr)
library(haven)
library(tibble)
library(gt)
raw_data_cleaned <- readr::read_csv("data/cleaned/cleaned_light.csv") #note that althhough this is called raw_data_cleaned, it is the equivalent of "cleaned_data_light" from data_prep.qmd. See that file to pull the version with old var names for D andP. Note: no power here.
#names(raw_data_cleaned)
#| eval: false
#| include: false
# List of deserving control variables
deserving_control_vars <- c(
"d_welfare_tanf_abc", "d_fstamps_snap_abc", "d_medicaid_abc", "d_medicare_abc",
"d_unemployed_abc", "d_poorfam_abc", "d_homeless_abc", "d_immigrants_abc",
"d_unauth_undoc_abc", "d_trans_abc", "d_transkids_abc",
"d_noncit_parent_a", "d_unins_c", "d_mentill_c"
)
# Create composite deservingness control variable
raw_data_cleaned <- raw_data_cleaned %>%
mutate(desor = rowMeans(select(., all_of(deserving_control_vars)), na.rm = TRUE))
view(raw_data_cleaned)
