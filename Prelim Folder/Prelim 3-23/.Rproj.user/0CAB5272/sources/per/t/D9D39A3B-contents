---
title: "data_prep"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,       # Hide code by default
  warning = FALSE,
  message = FALSE
)

# Load packages
library(dplyr)
library(tidyr)
library(readr)
library(janitor)   # for clean_names()
library(tibble)
library(stringr)
library(haven)

```

## 0. Preliminary - Load Data + Troubleshoot

```{r}
#| eval: false
#| include: false
# Unzip and load data

raw_data <- read_csv("./data/raw/scotg_results.csv")

names(raw_data)

raw_data <- clean_names(raw_data)
```

## 1. Cleaning

#### a. Label Deserving & Power Blocks

```{r}
#| include: false
#view(raw_data)
# DeservingPower Blocks

#FL_8_DO_Deserving&PowerBlockA %in% names(raw_data)

# Add participant block variable (group a, b, c)
raw_data <- raw_data %>%
  mutate(
    block = case_when(
      !is.na(`fl_8_do_deserving_power_block_a`) ~ "A",
      !is.na(`fl_8_do_deserving_power_block_b`) ~ "B",
      !is.na(`fl_8_do_deserving_power_block_c`) ~ "C",
      TRUE ~ NA_character_
    )
  )

# Save labeled but otherwise unmodified version
write_csv(raw_data, "./data/cleaned/labeled_raw_data.csv")

```

#### b. Create cleaned data frame, deleting un-needed cols

```{r}
#| include: false
#summary(raw_data)
columns_to_drop <- c(
  "status", "start_date", "end_date", "ip_address", "recipient_last_name", "recipient_first_name", 
  "recipient_email", "external_reference", "recorded_date", "location_latitude", 
  "location_longitude", "distribution_channel", "user_language"
)

names(raw_data)

# Drop all columns containing "_DO" (Display Order)

grep("_do_", names(raw_data), value = TRUE)

do_columns <- grep("_do", names(raw_data), value = TRUE)

# Drop everything
raw_data_cleaned <- raw_data %>%
  select(-all_of(c(columns_to_drop, do_columns)))

# Check
length(do_columns)


```

### c. Clean: drop non-consenters

```{r}
#| eval: false
#| include: false

# Filter to those who consented
raw_data_cleaned <- raw_data_cleaned %>%
  filter(consent == 1)

# Save again
write_csv(raw_data_cleaned, "data/cleaned/cleaned_data_consent.csv")

#remove consent col

raw_data_cleaned <- raw_data_cleaned %>%
  select(-consent)

```

### d. Clean: attn checks

-   first, create flags for passed/not each check and people who failed all

```{r}
#| eval: false
#| include: false

# 1. create logical variable (true/false) that marks whether respondent answered Q9 with 4
attn_check_q9 <- raw_data_cleaned$q9 == 4

#2. attention flag - tae text responses to Q17, remove leading/trailing spaces, and convert everything to lowercase for standardization)
attn_text <- tolower(str_trim(raw_data_cleaned$q17))

#2a. create list of acceptable answers for Q17
accepted_variants <- c("purple", "\"purple\"", "purpke", "purplee", "prurprle", "purpl", "purp", "üíú", "üü£")

#2b. chheck if each cleaned Q17 response is in thhe list of accepted variants. if yes, respondent passed attn check
attn_check_q17 <- attn_text %in% accepted_variants

#3. attn flag -- Create a flag for whether the respondent answered Q114_4 with a 6 (i.e., passed the third attention check
attn_check_q1114 <- raw_data_cleaned$q114_4 == 6

#If Q114_4 equals -99 (an invalid code), treat that as a failed check.
attn_check_q1114[raw_data_cleaned$q114_4 == -99] <- FALSE

#If Q114_4 is NA (they didn‚Äôt see the question), count that as a pass because they weren‚Äôt shown the question
attn_check_q1114[is.na(raw_data_cleaned$q114_4)] <- TRUE  # not shown ‚Üí pass

# 2. Create score + filter full failures
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    attn_q9_pass = attn_check_q9,
    attn_q17_pass = attn_check_q17,
    attn_q1114_pass = attn_check_q1114,
    attn_pass_count = as.integer(attn_q9_pass) + as.integer(attn_q17_pass) + as.integer(attn_q1114_pass)
  ) %>%
  filter(attn_pass_count > 0)  # Remove only people who failed all



```

### e. Clean: via survey duration

```{r}
#| eval: false
#| include: false

raw_data_cleaned <- raw_data_cleaned %>%
 mutate(duration_in_seconds = as.numeric(duration_in_seconds))

str(raw_data_cleaned$duration_in_seconds)

raw_data_cleaned$duration_sec <- as.numeric(raw_data_cleaned$duration_in_seconds)

raw_data_cleaned <- raw_data_cleaned %>%
  filter(duration_in_seconds >= 480)

```

### e. TBD Clean: ppl who do not answer my IV ??

## 2. Variables - Organize + Clean

### A. Deservingness and Power consolidation

Objective: consolidate blocks (so only 1 Incarcerated People/Prisoners)

```{r}
#| eval: false
#| include: false

mapping <- read_csv("./data/Unified_Deserving_Power_Target_Mapping.csv")

```

Prep by converting to numeric

```{r}
#| eval: false
#| include: false
# Identify all Deserving and Power columns
deserving_power_cols <- names(raw_data_cleaned)[str_detect(names(raw_data_cleaned), "^(Deserving|Power) Group")]

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(deserving_power_cols),
    as.character
  ))

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(deserving_power_cols),
    ~ as.numeric(na_if(.x, "-99"))
  ))

table(raw_data_cleaned$`Deserving Group A_1`, useNA = "always")

```

ALL Evals: Create consolidated variable names for deservingness ‚Äî OLD(?) can remove below?

```{r}
#| eval: false
#| include: false

#new_vars <- c(
#  "d_black_afam_abc", "d_native_ind_abc", "d_asianam_abc", "d_latino_his_abc", "d_whiteam_abc",
#  "d_mideastam_abc", "d_incwomen_abc", "d_collegewom_abc", "d_enviro_abc", "d_feminists_abc", 
#  "d_proabort_choice_abc", "d_abortprov_abc", "d_welfare_tanf_abc", "d_fstamps_snap_abc", 
#  "d_unions_abc", "d_medicaid_abc", "d_medicare_abc", "d_unemployed_abc", "d_police_abc", 
#  "d_poorfam_abc", "d_wealthy_abc", "d_teachers_abc", "d_sci_experts_abc", "d_child_abc", 
#  "d_crim_abc", "d_incppl_abc", "d_homeless_abc", "d_immigrants_abc", "d_unauth_undoc_abc", 
#  "d_gunowners_abc", "d_voters_abc", "d_lgbt_abc", "d_trans_abc", "d_transkids_abc", "d_gunmans_abc", 
#  "d_ice_abc", "d_socmed_abc", "d_nra_abc", "d_bigbank_abc", "d_bigcorp_abc", "d_uni_abc", 
#  "d_comcoll_abc", "d_noncit_parent_a", "d_incparents_a", "d_hsteen_a", "d_athiest_a", "d_cath_a", 
#  "d_evan_a", "d_jews_a", "d_pal_a", "d_muslim_a", "d_blackwom_a", "d_blackmen_a", "d_lds_a", 
#  "d_longcov_a", "d_exon_a", "d_weed_a", "d_opioid_a", "d_whitecol_a", "d_tech_a", "d_smokers_a", 
#  "d_genx_a", "d_boomer_a", "d_mill_a", "d_genz_a"
#)
#
#for (var in new_vars) {
#  raw_data_cleaned[[var]] <- NA #to initialize
#}
```

Ran new version of ABC loop to consolidate groups. Verified. After below, dataset in memory has unified variables. 

```{r}
library(readxl)
library(stringr)
library(dplyr)


# Load the mapping
mapping <- read_excel("scratch for consolidation.xlsx")
view(mapping)

# Clean column names and values in mapping to match raw_data_cleaned
mapping <- mapping %>%
  rename(
    var_a = `Deserving Group A`,
    var_b = `Deserving Group B`,
    var_c = `Deserving Group C`
  ) %>%
  mutate(
    var_a = str_replace_all(tolower(trimws(var_a)), " ", "_"),
    var_b = str_replace_all(tolower(trimws(var_b)), " ", "_"),
    var_c = str_replace_all(tolower(trimws(var_c)), " ", "_")
  )

# Create consolidated variables
for (i in 1:nrow(mapping)) {
  new_var <- mapping$target_slug[i]
  var_a <- mapping$var_a[i]
  var_b <- mapping$var_b[i]
  var_c <- mapping$var_c[i]
  
  # Optional check
  if (!all(c(var_a, var_b, var_c) %in% names(raw_data_cleaned))) {
    warning(paste("Missing column(s) for:", new_var))
  }

  raw_data_cleaned[[new_var]] <- dplyr::case_when(
  raw_data_cleaned$block == "A" ~ as.numeric(raw_data_cleaned[[var_a]]),
  raw_data_cleaned$block == "B" ~ as.numeric(raw_data_cleaned[[var_b]]),
  raw_data_cleaned$block == "C" ~ as.numeric(raw_data_cleaned[[var_c]]),
  TRUE ~ NA_real_
)
}

#verify: 

raw_data_cleaned %>%
  select(block, deserving_group_a_26, d_incppl_pris_abc) %>%
  filter(block == "A") %>%
  slice(1:10)
```

OLD: consolidating ABCs

```{r blockspecifictargets}
#| eval: false
#| include: false
# Load the spreadsheet with the mappings
library(readxl)
mapping <- read_excel("scratch for consolidation.xlsx")


#CHECKING
#view(mapping)
#view(raw_data_cleaned)
#colnames(raw_data_cleaned)

#clean mapping col names to match raw_data_cleaned
mapping <- mapping %>%
  mutate(
    `Deserving Group A` = str_replace_all(tolower(trimws(`Deserving Group A`)), " ", "_"),
    `Deserving Group B` = str_replace_all(tolower(trimws(`Deserving Group B`)), " ", "_"),
    `Deserving Group C` = str_replace_all(tolower(trimws(`Deserving Group C`)), " ", "_")
  )

#preview mapping to confirm fix
mapping %>%
  select(target_slug, `Deserving Group A`, `Deserving Group B`, `Deserving Group C`) %>%
  head(10)
print(
  mapping %>%
    select(target_slug, `Deserving Group A`, `Deserving Group B`, `Deserving Group C`) %>%
    head(10)
)

dim(mapping)  # shows number of rows and columns
print(mapping)
names(mapping)

# Create composite deservingness variables from the correct block column only
for (i in 1:nrow(mapping)) {
  new_var <- mapping$target_slug[i]
  var_a <- mapping$`Deserving Group A`[i]
  var_b <- mapping$`Deserving Group B`[i]
  var_c <- mapping$`Deserving Group C`[i]

  raw_data_cleaned[[new_var]] <- case_when(
    raw_data_cleaned$block == "A" ~ raw_data_cleaned[[var_a]],
    raw_data_cleaned$block == "B" ~ raw_data_cleaned[[var_b]],
    raw_data_cleaned$block == "C" ~ raw_data_cleaned[[var_c]],
    TRUE ~ NA_real_
  )
}

names(raw_data_cleaned)

```

LIMITED Deserving/power for 1 group only: recode groups directly

```{r}
#| eval: false
#| include: false

# Load the split mapping
split_map <- read.csv("./data/deserving_split.csv")

# Clean and normalize names to match raw_data_cleaned
split_map <- split_map %>%
  rename(old_var = `var.name`, new_var = target_slug) %>%
  mutate(
    old_var = str_replace_all(tolower(trimws(old_var)), " ", "_"),
    new_var = trimws(new_var)
  )

skipped <- list()

for (i in 1:nrow(split_map)) {
  old_var <- split_map$old_var[i]
  new_var <- split_map$new_var[i]

  # Only proceed if old_var is in dataset
  if (!(old_var %in% names(raw_data_cleaned))) {
    skipped[[new_var]] <- paste("Missing column:", old_var)
    next
  }

  # Check if there is *any valid data* (not -99)
  non_missing <- raw_data_cleaned[[old_var]] != -99 & !is.na(raw_data_cleaned[[old_var]])
  if (!any(non_missing, na.rm = TRUE)) {
    skipped[[new_var]] <- paste("No valid data in", old_var)
    next
  }

  # If we get here: create the new variable
  raw_data_cleaned[[new_var]] <- raw_data_cleaned[[old_var]]
}

if (length(skipped) > 0) {
  print("‚ö†Ô∏è Skipped variables:")
  print(skipped)
} else {
  print("‚úÖ All group-specific variables renamed successfully.")
}

names(raw_data_cleaned)

# OLD
# Loop through and rename each variable
#for (i in 1:nrow(split_map)) {
  
#  old_var <- split_map$var.name[i]     # e.g., "Deserving Group A_43"
#  new_var <- split_map$target_slug[i]  # e.g., "d_noncit_parent_a"
  
  # Just copy the values over
#  raw_data_cleaned[[new_var]] <- raw_data_cleaned[[old_var]]
#}

```

##### Clean -99s

```{r}
# Combine both sets of variables to clean
vars_to_clean <- c(mapping$target_slug, split_map$new_var)

# Only keep variables that exist in the dataset
vars_to_clean <- vars_to_clean[vars_to_clean %in% names(raw_data_cleaned)]

# Recode -99 to NA
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(all_of(vars_to_clean), ~ {
    if (is.character(.x)) {
      na_if(.x, "-99")  # character version
    } else if (is.numeric(.x)) {
      na_if(.x, -99)    # numeric version
    } else {
      .x  # leave unchanged
    }
  }))

sapply(raw_data_cleaned[vars_to_clean], class)

```

### prep for "light" version of csv without old deservingness vars (in lieu of consoldiated and renamed)

```{r}
#vector of old variable names
block_vars_to_drop <- grep("^(deserving_group|power_group)_[abc]_", names(raw_data_cleaned), value = TRUE)

#create version with them dropped
cleaned_data_light <- raw_data_cleaned %>%
  select(-all_of(block_vars_to_drop))

view(cleaned_data_light)

```

### LAST: Save to file.

```{r}

write_csv(raw_data_cleaned, "data/cleaned/cleaned_data_consent.csv")

#light csv
write_csv(cleaned_data_light, "data/cleaned/cleaned_light.csv") # main file to use going forward

```

# ARCHIVED CODE

```{r}
# Making "unique" combinations that include possible accidental "both incarcerated and none." I'm erring on the side of caution, given these are sensitive questions that might confuse participants. For example, someone might quickly check "myself," but then see "someone you know" followed by "don't know/unsure", and think the latter is in regards to knowing someone who has been incarcerated or victimized. I'll run the models with different versions."

  contact_pattern = c(
    "100000",  # Incarcerated Only
    "100001",  # Incarcerated Only
    "101001",  # Incarcerated Only
    "101000",  # Incarcerated Only
    
    "010000",  # Knows Inc Only
    "010001",  # Knows Inc Only
    "011001",  # Knows Inc Only
    "011000",  # Knows Inc Only
    
    "001100",  # Victim Only
    "001101",  # Victim Only
    "000100",  # Victim Only
    "000101",  # Victim Only
    
    "110000",  # Inc, Knows Inc
    "110001",  # Inc, Knows Inc
    "111001",  # Inc, Knows Inc
    "111000",  # Inc, Knows Inc
    
    
    "100100",  # Inc, Vict
    "100101",  # Inc, Vict
    "101100",  # Inc, Vict
    "101101",  # Inc, Vict
    
    "100010",  # Inc, Knows Vict
    "101011",  # Inc, Knows Vict
    "100011",  # Inc, Knows Vict
    "101010",  # Inc, Knows Vict
    
    "010100",  # Knows Inc, Vict
    "010101",  # Knows Inc, Vict
    "011101",  # Knows Inc, Vict
    "011100",  # Knows Inc, Vict
    
    "110100",  # Inc, Knows Inc, Vict
    "110101",  # Inc, Knows Inc, Vict
    "111101",  # Inc, Knows Inc, Vict

    "010110",  # Knows Inc, Vict, Knows Vict
    "011111",  # Knows Inc, Vict, Knows Vict
    "011110",  # Knows Inc, Vict, Knows Vict
    "010111",  # Knows Inc, Vict, Knows Vict
    
    "110110",  # All
    "111110",  # All
    "110111",  # All
    "111111",  # All
    
    "011100"   # Also and only KI
  )


```
