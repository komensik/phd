---
title: "variable_prep_script"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,       # Hide code by default
  warning = FALSE,
  message = FALSE
)

# Load packages
library(dplyr)
library(tidyr)
library(readr)
library(janitor)   # for clean_names()
library(tibble)
library(stringr)
library(haven)
library(tibble)
library(gt)

```

## 1. Directory of Most Recent Data

Load cleaned survey data

File created in data_prep.qmd

```{r}
view(raw_data_cleaned)

#raw_data_cleaned <- readr::read_csv("data/cleaned/cleaned_light.csv") 
#CONTINGENT note that alhough this is called raw_data_cleaned, it is the equivalent of "cleaned_data_light" from data_prep.qmd. See that file to pull the version with old var names for D and P. Note: no power here.

names(raw_data_cleaned)

```

## 2. Variables

### A. Deservingness and Power consolidation

```{r, prisonerdeserves}

# pretty much done, maybe standardize later?

```

Standardize? No -- in my prelim, I write: To ensure that I do not control for a variable that is conceptually or empirically too close to the deservingness of incarcerated people when it is the dependent variable, I exclude any deservingness ratings for groups that are substantively overlapping or highly correlated. Including those could absorb variance in the outcome or introduce post-treatment bias by controlling for a related evaluative construct. I also avoid using global composite or average deservingness scores across all groups – for example, a respondent's mean deservingnesss rating across all 65 groups they evaluated – because that composite would include the rating of incarcerated people itself, introducing potential collinearity and making it difficult to isolate the unique effect of contact. This modeling strategy attempts to preserve interpretability and ensuring that the effect of policy contact is estimated with respect to unstandardized, target-specific deservingness scores. 12

12 While constructing composite or control variables involving other deservingness targets, I assess whether their inclusion introduces collinearity or conceptual overlap with the dependent variable. In particular, I examine correlations between group-level deservingness ratings to ensure that any included groups are not too closely tied to perceptions of incarcerated people. If preliminary checks reveal that including a particular group (e.g., “criminals” or “formerly incarcerated individuals”) would obscure key variance or conflate target constructs, I exclude it from the model and treat it as conceptually non-distinct for the purposes of this analysis.

#### Deservingness Orientation Control

Creating a core composite score for groups evaluated by all 3 ABC first. Flagging will want to use extended version with targets evaluated by just one of the 3 ABC: "d_unins_c", "d_noncit_parent_a", "d_mentill_c"

```{r desor}

names(raw_data_cleaned)

summary(raw_data_cleaned$d_mentill_c)

#NEW (OCT 27) DESOR

desor_core_vars <- c(
  "d_welfare_tanf_abc","d_fstamps_snap_abc","d_medicaid_abc","d_medicare_abc",
  "d_unemployed_abc","d_poorfam_abc","d_homeless_abc","d_immigrants_abc","d_unauth_undoc_abc"
)

# below, try to keep only things in current dataset / prevent old code constructs I don't want to include
core_vars <- intersect(desor_core_vars, names(raw_data_cleaned))
# Takes the vector  defined earlier (desor_core_vars) and keeps only those names that actually exist in the current data. Prevents errors if a column is missing or was renamed

core_mat  <- dplyr::select(raw_data_cleaned, dplyr::all_of(core_vars))
#Builds a mini data frame (matrix) containing only the core variables (columns) from dataset.

core_n    <- rowSums(!is.na(core_mat))
#For each respondent (row), counts how many core items are non-missing. Will be used to enforce minimum answered-items rule

raw_data_cleaned$desor_core   <- ifelse(core_n >= 5, rowMeans(core_mat, na.rm = TRUE), NA_real_)
# Creates the core composite. With 9 core items, “≥5” ≈ a 50% completeness rule—balances coverage and reliability.

raw_data_cleaned$desor_core_z <- as.numeric(scale(raw_data_cleaned$desor_core))
# Makes a standardized version (z-score) of the core composite (mean 0, sd 1).
# Convenient for regression comparability and coefficient interpretation.


# EXTENDED VERSION -- groups only evaluated by 1 of ABC. For robustness. 
desor_ext_vars <- c(desor_core_vars, "d_unins_c", "d_mentill_c", "d_noncit_parent_a")
ext_vars <- intersect(desor_ext_vars, names(raw_data_cleaned))
ext_mat  <- dplyr::select(raw_data_cleaned, dplyr::all_of(ext_vars))
ext_n    <- rowSums(!is.na(ext_mat))
raw_data_cleaned$desor_ext    <- ifelse(ext_n >= 6, rowMeans(ext_mat, na.rm = TRUE), NA_real_)
raw_data_cleaned$desor_ext_z  <- as.numeric(scale(raw_data_cleaned$desor_ext))

# Check
summary(raw_data_cleaned$desor_core); table(core_n)
summary(raw_data_cleaned$desor_ext);  table(ext_n)

summary(raw_data_cleaned$desor_core); table(core_n, useNA="ifany")
summary(raw_data_cleaned$desor_ext);  table(ext_n,  useNA="ifany")


```

Section Conclusion: - creates composite desor Main specs: use desor_core_z.

Robustness: re-estimate with desor_ext_z and add + factor(block) (or + block) to your regressions.

Keep justice-adjacent targets out of both composites.

#### Deservingness Orientation Control -- Checks

```{r}
library(psych)


# reliability -- Core
psych::alpha(select(raw_data_cleaned, all_of(core_vars)))

core_mat <- dplyr::select(raw_data_cleaned, dplyr::all_of(core_vars))
core_keep <- rowSums(!is.na(core_mat)) >= 5        # match your ≥5 rule
core_alpha <- psych::alpha(core_mat[core_keep, ], check.keys = TRUE)

core_alpha$total$raw_alpha   # Cronbach’s alpha (raw)
core_alpha$total$std.alpha   # Alpha based on standardized items
core_alpha$total$average_r   # Average inter-item correlation
core_alpha$n.obs             # N used after listwise deletion
core_alpha$alpha.drop        # “if item deleted” table
core_alpha$item.stats        # item means, sd, r.drop, etc.
```

Interpretation: raw_alpha: 0.9078 and 0.9142 internal consistency -- suggests items hang together well. average_r = 0.5422 -- high inter-item correlation. cor: fairly strong correlation to the DV (0.547) R\^2 = 0.30 bivariately. Soaks up general generosity toward assistance-framed groups. Should justify use of control for testing whether contact predicts deservingness of incarcerated people, above and beyond that general orientation.

```{r}
# reliability -- EXT

ext_mat  <- dplyr::select(raw_data_cleaned, dplyr::all_of(ext_vars))
ext_keep <- rowSums(!is.na(ext_mat)) >= 6
# alpha on complete cases after the ≥6 rule
psych::alpha(na.omit(ext_mat[ext_keep, ]), check.keys = TRUE)

#  per-block alphas
psych::alpha(na.omit(ext_mat[ext_keep & raw_data_cleaned$block=="A", ]), check.keys = TRUE)
psych::alpha(na.omit(ext_mat[ext_keep & raw_data_cleaned$block=="B", ]), check.keys = TRUE)
psych::alpha(na.omit(ext_mat[ext_keep & raw_data_cleaned$block=="C", ]), check.keys = TRUE)

```

```{r}
#standardize
raw_data_cleaned$desor_core_z <- as.numeric(scale(raw_data_cleaned$desor_core))
raw_data_cleaned$desor_ext_z  <- as.numeric(scale(raw_data_cleaned$desor_ext))

```

#### A1. Deserving Validation

```{r}
#CHECK INDIVIDUALS
#raw_data_cleaned %>%
#  filter(ResponseId == "R_5DugmlzJSCFvja1") %>%
 # select(block, `Deserving Group A_1`, d_black_afam_abc)

```

### B. Q4 - Experiences Block -- ie Incarcerated Combos

```{r, cleaningexperiences1}

#view(raw_data_cleaned$Q4_1_1)

# Basic Totals
#I’m counting how many people said they themselves have been incarcerated by checking where Q4_1_1 equals 1. I’m ignoring missing values
total_incarcerated <- sum(raw_data_cleaned$q4_1_1 == 1, na.rm = TRUE)

#"I’m counting how many people said they know someone who’s been incarcerated (Q4_1_2 == 1). Again, I’m skipping over any missing answers."
total_knows_incarcerated <- sum(raw_data_cleaned$q4_1_2 == 1, na.rm = TRUE)

#I’m counting how many people selected ‘no / unsure’ when asked about incarceration experience (Q4_1_3 == 1)
total_no_incarcerated <- sum(raw_data_cleaned$q4_1_3 == 1, na.rm = TRUE)

#I’m counting how many respondents said they themselves were a victim of violent crime.
total_victim <- sum(raw_data_cleaned$q4_2_1 == 1, na.rm = TRUE)

#I’m counting how many said they know someone who was a victim of violent crime
total_knows_victim<- sum(raw_data_cleaned$q4_2_2 == 1, na.rm = TRUE)

#I’m counting those who selected ‘no / unsure’ for victimization experience
total_no_victim <- sum(raw_data_cleaned$q4_2_3 == 1, na.rm = TRUE)
```

#### Impact Variable

```{r, impactvar}

#counting the *total* of those who said they were incarcerated, know incarcerated, or victims)

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    impact = if_else(
      q4_1_1 == 1 | q4_1_2 == 1 | q4_2_1 == 1,
      1, 0,
      missing = NA_real_
    )
  )

#specific binary impact indicators

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    incarc = if_else(
      q4_1_1 == 1,
      1, 
      0,
      missing = NA_real_
    )
  )

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    knowincarc = if_else(
      q4_1_2 == 1,
      1, 
      0,
      missing = NA_real_
    )
  )

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    noincarc = if_else(
      q4_1_1 == 0 | q4_1_2 == 0 | q4_1_3 == 1,
      1, 0,
      missing = NA_real_
    )
  )

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    vict = if_else(
      q4_2_1 == 1,
      1, 
      0,
      missing = NA_real_
    )
  )


```

Create fingerprint

-   create a new variable named contact_pattern

-   for each respondent, create a 6 digit code that summarizes how they answered each Q4_1 and Q4_2 question

    -   if the person said yes (1), use that 1. If they didn't answer, treat it as 0

-   combine all 6 digits starting with incarceration responses then victimization to create pattern to put in var

```{r, experiencesfingerprints1}
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    contact_pattern = paste0(
      coalesce(q4_1_1, 0),
      coalesce(q4_1_2, 0),
      coalesce(q4_1_3, 0),
      coalesce(q4_2_1, 0),
      coalesce(q4_2_2, 0),
      coalesce(q4_2_3, 0)
    )
  )

count(raw_data_cleaned, contact_pattern)

```

#### Coding Note –

Some respondents selected both a contact experience (e.g., "been incarcerated") and also marked “none/unsure”, which is logically inconsistent. These may reflect confusion, misclicks, or low-quality responses.

Conflict Type Count Q4_1_1 (Been incarcerated) & Q4_1_3 (None/Unsure) 1 Q4_1_2 (Knows incarcerated) & Q4_1_3 (None/Unsure) 1 Q4_2_1 (Been victimized) & Q4_2_3 (None/Unsure) 10 Q4_2_2 (Knows victim) & Q4_2_3 (None/Unsure) 10

```{r, experiencesfingerprints}
#table(raw_data_cleaned$Q4_1_3, useNA = "always")
#table(raw_data_cleaned$Q4_2_3, useNA = "always")


strange1 <- raw_data_cleaned %>%
  filter(q4_1_1 == 1 & q4_1_3 == 1)  

strange2 <- raw_data_cleaned %>%
  filter(q4_1_2 == 1 & q4_1_3 == 1) 

strange3 <- raw_data_cleaned %>%
  filter(q4_2_1 == 1 & q4_1_3 == 1) 

strange4 <- raw_data_cleaned %>%
  filter(q4_2_2 == 1 & q4_1_3 == 1) 

print(strange1)
print(strange2)
print(strange3)
print(strange4)


#
count(raw_data_cleaned, contact_pattern)


```

Tabulate unique patterns

```{r, allexperienceuniquecombos}

combo_summary <- raw_data_cleaned %>%
  group_by(contact_pattern) %>%
  summarise(
    N = n(),
    pct_total = 100 * n() / nrow(raw_data_cleaned),
    pct_of_been_incarcerated = 100 * sum(q4_1_1 == 1, na.rm = TRUE) / total_incarcerated,
    pct_of_knows_incarcerated = 100 * sum(q4_1_2 == 1, na.rm = TRUE) / total_knows_incarcerated,
    pct_of_been_victim = 100 * sum(q4_2_1 == 1, na.rm = TRUE) / total_victim
  ) %>%
  arrange(desc(N))
```

```{r}

gracious_recode <- tibble::tibble(
 contact_pattern = c(
  "100000", "100001", "101001", "101000", #Incarcerated Only
  "010000", "010001", "011001", "011000",  # Knows Inc Only
  "001100", "001101", "000100", "000101",  # Victim Only
  "110000", "110001", "111001", "111000", # Inc, Knows Inc
  "010100", "010101", "011101", "011100",  
  "110100", "110101", "111101", # Inc, Knows Inc, Vict
  "010110", "011111", "011110", "010111",  # Knows Inc, Vict, Knows Vict
  "110110",  "111110", "110111", "111111",  # All
 ),
  label = c(
    "Incarcerated Only",
    "Knows Inc Only",
    "Victim Only",
    "Inc, Knows Inc",
    "Knows Inc, Vict",
    "Inc, Knows Inc, Vict",
    "Knows Inc, Vict, Knows Vict",
    "Also Vict",
    "Also and only Vict",
    "Victim Only",
    "Also and only KI"
  )
)


```

```{r, exploratoryimpactdataframe}

# Step 1: Create the pattern-to-label lookup
pattern_lookup <- tibble::tibble(
  contact_pattern = c(
    "100000", "100001", "101001", "101000",
    "010000", "010001", "011001", "011000",
    "001100", "001101", "000100", "000101",
    "110000", "110001", "111001", "111000",
    "100100", "100101", "101100", "101101",
    "100010", "101011", "100011", "101010",
    "010100", "010101", "011101", "011100",
    "110100", "110101", "111101",
    "010110", "011111", "011110", "010111",
    "110110", "111110", "110111", "111111"
  ),
  label = c(
    rep("Incarcerated Only", 4),
    rep("Knows Incarcerated Only", 4),
    rep("Victim Only", 4),
    rep("Inc & Knows Inc", 4),
    rep("Inc & Vict", 4),
    rep("Inc & Knows Vict", 4),
    rep("Knows Inc & Vict", 4),
    rep("Inc, Knows Inc, Vict", 3),
    rep("Knows Inc, Vict, Knows Vict", 4),
    rep("All", 4)
  )
)

# Step 2: Join this to dataset and count
pattern_counts <- raw_data_cleaned %>%
  inner_join(pattern_lookup, by = "contact_pattern") %>%
  count(label, contact_pattern, name = "count") %>%
  arrange(label, desc(count))

# View the result
print(pattern_counts)


```

### charts

```{r}

# Calculate basic totals
table_a <- tibble::tibble(
  Type = c("Been Incarcerated", "Knows Incarcerated", "Been Victimized"),
  Count = c(total_incarcerated, total_knows_incarcerated, total_victim),
  Percent_of_Sample = round(100 * Count / nrow(raw_data_cleaned), 1)
)

table_a %>%
  gt() %>%
  cols_label(
    Type = "Type",
    Count = "Total Count",
    Percent_of_Sample = "Percent of Sample"
  ) %>%
  tab_header(title = "Appendix Table A. Basic Contact Types") %>%
  tab_options(table.font.size = "small")

```

```{r}

combo_appendix_data %>%
  filter(label %in% c(
    "Incarcerated Only",
    "Also KI",
    "Also and only KI",
    "Also Vict",
    "Also and only Vict",
    "Also KI and Vict",
    "Also and only KI and Vict"
  )) %>%
  select(label, N, pct_total, pct_of_incarcerated) %>%
  arrange(desc(N)) %>%
  gt() %>%
  cols_label(
    label = "Contact Combo",
    N = "Count",
    pct_total = "Percent of Sample",
    pct_of_incarcerated = "Percent of Total Incarcerated Count"
  ) %>%
  fmt_number(columns = where(is.numeric), decimals = 1) %>%
  tab_header(title = "Appendix Table B. Incarcerated (Inc) Combos") %>%
  tab_options(table.font.size = "small")

```

```{r}

combo_appendix_data %>%
  filter(label %in% c(
    "KI Only",
    "Also Vict",
    "Also and only Vict"
  )) %>%
  select(label, N, pct_total, pct_of_ki) %>%
  arrange(desc(N)) %>%
  gt() %>%
  cols_label(
    label = "Contact Combo",
    N = "Count",
    pct_total = "Percent of Sample",
    pct_of_ki = "Percent of Total KI Count"
  ) %>%
  fmt_number(columns = where(is.numeric), decimals = 1) %>%
  tab_header(title = "Appendix Table C. Knows Incarcerated (KI) Combos") %>%
  tab_options(table.font.size = "small")
```

```{r}

combo_appendix_data %>%
  filter(label %in% c(
    "Victim Only",
    "Also KI",
    "Also and only KI"
  )) %>%
  select(label, N, pct_total, pct_of_victim) %>%
  arrange(desc(N)) %>%
  gt() %>%
  cols_label(
    label = "Contact Combo",
    N = "Count",
    pct_total = "Percent of Sample",
    pct_of_victim = "Percent of Total Victim Count"
  ) %>%
  fmt_number(columns = where(is.numeric), decimals = 1) %>%
  tab_header(title = "Appendix Table D. Victim (VI) Combos") %>%
  tab_options(table.font.size = "small")

```

```{r Incarcerated Combos}
#| eval: false
#| include: false

incarcerated_only <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

incarcerated_knowsinc <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

inc_knowsinc_victim <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

inc_knowsinc_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)


inc_knowsinc_victim_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

incarcerated_victim <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

inc_victim_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

incarcerated_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 1 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)


knowsinc_only <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

knowsinc_victim <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

knowsinc_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 0 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

knowsinc_victim_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 1 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

vict_only <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

victim_knowsvict <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 1 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

knowsvict_only <- sum(
  raw_data_cleaned$Q4_1_1 == 0 &
  raw_data_cleaned$Q4_1_2 == 0 &
  raw_data_cleaned$Q4_1_3 == 0 &
  raw_data_cleaned$Q4_2_1 == 1 &
  raw_data_cleaned$Q4_2_2 == 0 &
  raw_data_cleaned$Q4_2_3 == 0 &
  !is.na(raw_data_cleaned$Q4_1_1) &
  !is.na(raw_data_cleaned$Q4_1_2) &
  !is.na(raw_data_cleaned$Q4_1_3) &
  !is.na(raw_data_cleaned$Q4_2_1) &
  !is.na(raw_data_cleaned$Q4_2_2) &
  !is.na(raw_data_cleaned$Q4_2_3)
)

#data frame
contact_counts <- tibble::tibble(
  total_incarcerated = total_incarcerated,
  total_knows_incarcerated = total_knows_incarcerated,
  total_no_incarcerated = total_no_incarcerated,
  total_victim = total_victim,
  total_knows_victim = total_knows_victim,
  total_no_victim = total_no_victim,
  incarcerated_only = incarcerated_only,
  incarcerated_knowsinc = incarcerated_knowsinc,
  inc_knowsinc_victim = inc_knowsinc_victim,
  inc_knowsinc_knowsvict = inc_knowsinc_knowsvict,
  inc_knowsinc_victim_knowsvict = inc_knowsinc_victim_knowsvict,
  incarcerated_victim = incarcerated_victim,
  inc_victim_knowsvict = inc_victim_knowsvict,
  incarcerated_knowsvict = incarcerated_knowsvict,
  knowsinc_only = knowsinc_only,
  knowsinc_victim = knowsinc_victim,
  knowsinc_knowsvict = knowsinc_knowsvict,
  knowsinc_victim_knowsvict = knowsinc_victim_knowsvict,
  vict_only = vict_only,
  victim_knowsvict = victim_knowsvict,
  knowsvict_only = knowsvict_only
)

write_csv(contact_counts, "filled_contact_combo_counts.csv")


#view(contact_counts)

```

#### Tables

```{r}
combo_summary_labeled %>%
  select(label, contact_pattern, N, pct_total) %>%
  arrange(desc(N)) %>%
  gt() %>%
  cols_label(
    contact_pattern = "Q4 Pattern",
    label = "Description",
    N = "N",
    pct_total = "% of Sample"
  ) %>%
  fmt_number(columns = where(is.numeric), decimals = 1) %>%
  tab_header(title = "Appendix Table A. Full Distribution of Q4 Contact Combinations") %>%
  tab_options(table.font.size = "small")


print(combo_summary_labeled)
```

### C. Q6, 7, 8 - Ration Block

```{r}

#inspect

#raw_data %>% select(q6, q7, q8) %>% summarise_all(~ list(unique(.)))

# clean and transform
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    c(q6, q7, q8), 
    ~ na_if(as.numeric(.x), -99)
    )) %>% mutate(across(
    c(q6, q7, q8),
    ~ factor(.x, levels = 1:4,
             labels = c("Frequently", "Sometimes", "Rarely", "Never"),
             ordered = TRUE)
  ))

 raw_data_cleaned %>% count(q8)

```

### D. Prison & Election Policy Questions

#### "Punitiveness" - Prison for punishment or rehab?

```{r, punishorrehab}
#for 62_1, originally 1 was punish and 7 was rehabilitate people

# Renamed raw column to a more intuitive name
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(q62_1 = na_if(as.numeric(q62_1), -99))

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(penalpoint = 8 - q62_1) #reverse coded so 7 = most punitive

# Create ordered factor version of the reverse-coded scale (7 = most punitive)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(penalpoint_ord = factor(
    penalpoint,
    levels = 1:7,
    labels = c(
      "Rehab (1)", "Rehab (2)", "Rehab (3)", "Neutral (4)",
      "Punish (5)", "Punish (6)", "Punish (7)"
    ),
    ordered = TRUE
  ))

# NOTE: Factor version of PenalPunitiveness (reverse-coded already: 1 = least punitive, 7 = most punitive)

# Tabulate raw values in Q62_1

# Count how many times -99 appears in the whole dataset
#sum(raw_data_cleaned == -99, na.rm = TRUE)



```

#### Support for Punitive Prison Policy (death penalty and LWOP) - prisonpen

```{r, prisonpen}
#Q25_1 and Q25_5, death penalty and LWOP
 #raw_data_cleaned %>% count(Q25_1)

#recode Q25_1:  -99 (na_if converts to numeric)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(q25_1 = na_if(as.numeric(q25_1), -99))

# Recode Q25_5 the same way
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(q25_5 = na_if(as.numeric(q25_5), -99))

# Code prisonpen subitems (dpen, lwop), NA if "Don't know" (5)
# Create cleaned subcomponents
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    prisonpen_1 = case_when(q25_1 %in% 1:4 ~ q25_1, TRUE ~ NA_integer_),
    prisonpen_5 = case_when(q25_5 %in% 1:4 ~ q25_5, TRUE ~ NA_integer_)
  )

# Compute index (after subcomponents exist)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(prisonpen = rowMeans(select(., prisonpen_1, prisonpen_5), na.rm = TRUE))

#unsure if above worked

#different way to confirm that prison pen was constructed right -- confirmed that summary of new prison pen is same as old version. Keep using prisonpen.
mutate(prisonpen = rowMeans(select(., c(prisonpen_1, prisonpen_5)), na.rm = TRUE))

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(prisonpen_redo = rowMeans(across(c(prisonpen_1, prisonpen_5)), na.rm = TRUE))

summary(raw_data_cleaned$prisonpen_1)
summary(raw_data_cleaned$prisonpen_5)
summary(raw_data_cleaned$prisonpen)

```

Takeaway: prison pen, prison pen 1 = dpen, prison pen 5 = lwop now -confirmed that prisonpen works -- constructed with average of death penalty and lwop

OPTIONAL/potentially helpful for tables: factor version

```{r, q25_1_ord}
#OPTIONAL/potentially helpful for tables: factor version
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(q25_1_ord = factor(
    q25_1,
    levels = 1:5,
    labels = c("Strongly favor", "Favor", "Oppose", "Strongly oppose", "Don't know"),
    ordered = TRUE
  ))
```

#### Support for 'Help-Oriented' Prison Policy.

These will include prison and election policies. Here, I first set up the prison policy Q's, then prison/voting Q's.

```{r, prisonhelp}
# Define Q25 help-oriented items
q25_help_items <- c("q25_2", "q25_3", "q25_4", "q25_6")

# Step 1: Recode -99 to NA and ensure numeric
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(all_of(q25_help_items), ~ na_if(as.numeric(.), -99)))

# Step 2: Create reverse-coded versions (1 = strong favor → 4 = strong oppose becomes 4 → 1)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(q25_help_items),
    ~ ifelse(. %in% 1:4, 5 - ., .),  # note: we skip 5 = DK
    .names = "{.col}_rev"
  ))

summary(raw_data_cleaned$q25_2_rev)
```

OPTIONAL: Create ordered factor versions- could be useful for plotting/tables/labeling)

```{r, prisonhelp_factor}

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(q25_help_items),
    ~ factor(.,
             levels = 1:5,
             labels = c("Strongly favor", "Favor", "Oppose", "Strongly oppose", "Don't know"),
             ordered = TRUE),
    .names = "{.col}_ord"
  ))

```

Delivers: q25_help_items

##### Add Prison/Election (q23) questions to Above

```{r, electionhelpqs}

# Step 1: Recode -99 to NA and ensure numeric
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(all_of(q25_help_items), ~ na_if(as.numeric(.), -99)))

# Step 2: Create reverse-coded versions (1 = strong favor → 4 = strong oppose becomes 4 → 1)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(q25_help_items),
    ~ ifelse(. %in% 1:4, 5 - ., .),  # note: we skip 5 = DK
    .names = "{.col}_rev"
  ))

# Step 3: Create ordered factor versions (optional, if needed for plotting or labeling)
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(q25_help_items),
    ~ factor(.,
             levels = 1:5,
             labels = c("Strongly favor", "Favor", "Oppose", "Strongly oppose", "Don't know"),
             ordered = TRUE),
    .names = "{.col}_ord"
  ))


names(raw_data_cleaned) %>% stringr::str_subset("q25|q23")

# Define Q23 help-oriented items (election)


# prisonhelp index

# Construct composite index (average of 6 items)
# rev gives reverse version of the arguments
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(prisonhelp = rowMeans(select(., 
    q25_2_rev, q25_3_rev, q25_4_rev, q25_6_rev, q23_2_rev, q23_7_rev
  ), na.rm = TRUE))


#checking that above (construction of prisonhelp) worked even though codechunk won't re-run. 
#CONFIRMED
#raw_data_cleaned <- raw_data_cleaned %>%
#  mutate(prisonhelp_redo = rowMeans(across(c(q25_2_rev, q25_3_rev, #q25_4_rev, q25_6_rev, q23_2_rev, q23_7_rev)), na.rm = TRUE))


#checking variance + SD here (Oct 28)
#summary(raw_data_cleaned$prisonhelp)
#summary(raw_data_cleaned$prisonhelp_redo)
# c_across: works with rowwise for performing row-wise aggregations. Different from c() in that it uses tidy select semantics to make it easier to select multiple variances
print(var(c_across(all_of(prisonhelp)))
      
```

#### D1. Variance and Stand Dev why do I reconstruct?

```{r}
#don't need to redo this
#help_policy_items <- c("q25_2", "q25_3", "q25_4", "q25_6", "q23_2", "q23_7")

# Variance and SD across help policy items
raw_data_cleaned <- raw_data_cleaned %>%
  rowwise() %>%
  mutate(
    variancehelp = var(c_across(all_of(help_policy_items)), na.rm = TRUE),
    sdhelp = sd(c_across(all_of(help_policy_items)), na.rm = TRUE)
  ) %>%
  ungroup()


```

### E. Prison Policy Orientation (polor) control

```{r}
#| eval: false
#| include: false

help_policy_items <- c("q25_2", "q25_3", "q25_4", "q25_6", "q23_2", "q23_7")

# Variance and SD across help policy items
raw_data_cleaned <- raw_data_cleaned %>%
  rowwise() %>%
  mutate(
    variancehelp = var(c_across(all_of(help_policy_items)), na.rm = TRUE),
    sdhelp = sd(c_across(all_of(help_policy_items)), na.rm = TRUE)
  ) %>%
  ungroup()


```

10-27 Diagnostics

```{r}
names(raw_data_cleaned) %>% stringr::str_subset("q25|q23|q62|prison|help|punish|rehab")

glimpse(raw_data_cleaned %>% select(starts_with("q25"), starts_with("q23"), starts_with("q62"), starts_with("prison"), starts_with("penal")))


glimpse(dplyr::select(raw_data_cleaned,
                      starts_with("q25_"),
                      starts_with("q23_"),
                      starts_with("q62"),
                      starts_with("prison"),
                      starts_with("penal")))

```

Vars exist: \[1\] "q62_1" "q25_1"\
\[3\] "q25_2" "q25_3"\
\[5\] "q25_4" "q25_5"\
\[7\] "q25_6" "q23_1"\
\[9\] "q23_2" "q23_3"\
\[11\] "q23_4" "q23_5"\
\[13\] "q23_6" "q23_7"\
\[15\] "q25_1_ord" "prisonpen_1" \[17\] "prisonpen_5" "prisonpen"\
\[19\] "q25_2_ord" "q25_3_ord"\
\[21\] "q25_4_ord" "q25_6_ord"\
\[23\] "q23_2_ord" "q23_7_ord"\
\[25\] "q23_2_rev" "q23_7_rev"\
\[27\] "q25_2_rev" "q25_3_rev"\
\[29\] "q25_4_rev" "q25_6_rev"\
\[31\] "prisonhelp" "variancehelp" \[33\] "sdhelp"

Code that gives errors:

# Compute index (after subcomponents exist)

raw_data_cleaned \<- raw_data_cleaned %\>% mutate(prisonpen = rowMeans(select(., prisonpen_1, prisonpen_5), na.rm = TRUE))

# prisonhelp index

# Construct composite index (average of 6 items)

# rev gives reverse version of the arguments

raw_data_cleaned \<- raw_data_cleaned %\>% mutate(prisonhelp = rowMeans(select(., q25_2_rev, q25_3_rev, q25_4_rev, q25_6_rev, q23_2_rev, q23_7_rev ), na.rm = TRUE))

### F. FIRE controls

```{r}

#raw_data_cleaned %>% count(q32)

#raw_data_cleaned %>% count(Q33)

#raw_data_cleaned %>% count(Q34)

#raw_data_cleaned %>% count(Q111)

fire_vars <- c("q32", "q33", "q34", "q111")

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(
    all_of(fire_vars),
    ~ as.numeric(na_if(as.character(.x), "-99"))
  ))

raw_data_cleaned <- raw_data_cleaned %>%
  rename(
    fire_rare = q32,
    fire_privilege = q33,
    fire_angry = q34,
    fire_fear = q111
  )

summary(raw_data_cleaned$fire_angry)
summary(raw_data_cleaned$fire_privilege)
summary(raw_data_cleaned$fire_fear)
summary(raw_data_cleaned$fire_rare)


```

### G. Race

```{r}

#convert + clean
race_vars <- paste0("q51_", 1:8)

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(all_of(race_vars), ~ na_if(as.numeric(.x), -99)))

# REPLACE your current race dummies with this block
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    # Ethnicity first: Hispanic gets priority
    Hispanic = ifelse(q51_7 == 1, 1, 0),

    # Among non-Hispanics, assign Black and White
    Black    = ifelse(q51_2 == 1 & q51_7 != 1, 1, 0),
    White    = ifelse(q51_1 == 1 & q51_7 != 1, 1, 0)
  ) %>%
  mutate(
    # Everyone else with any race selection becomes OtherRace (mutually exclusive)
    OtherRace = ifelse(
      (Black + Hispanic + White) == 0 &
        rowSums(dplyr::select(., dplyr::all_of(race_vars)), na.rm = TRUE) > 0,
      1, 0
    )
  )

```

DOUBLE CHECK

```{r}

# no overlaps among the 4 dummies
sum((raw_data_cleaned$Black + raw_data_cleaned$White +
     raw_data_cleaned$Hispanic + raw_data_cleaned$OtherRace) > 1, na.rm = TRUE)

# counts by category (mutually exclusive)
table(
  with(raw_data_cleaned,
       dplyr::case_when(
         Hispanic == 1 ~ "Hispanic",
         Black    == 1 ~ "Black",
         White    == 1 ~ "White",
         OtherRace== 1 ~ "OtherRace",
         TRUE          ~ NA_character_
       )),
  useNA = "ifany"
)


```

Diagnosed problem in model where Black + Other dropped - Oct 27 Suggests all Black respondents had missing data so were dropped

### H. Party + Ideology controls

```{r}

#raw_data_cleaned %>% count(q47)

#clean dem 101
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(dem101 = na_if(as.numeric(dem101), -99))

#party ID dummies
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    Republican = ifelse(dem101 == 1, 1, 0),
    Democrat = ifelse(dem101 == 2, 1, 0)
  )
(raw_data_cleaned$Republican)

#clean ideology
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    q46 = na_if(as.numeric(q46), -99),
    q47 = na_if(as.numeric(q47), -99)
  )

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(
    fiscal_ideology = ifelse(!is.na(q46), 6 - q46, NA),
    social_ideology = ifelse(!is.na(q47), 6 - q47, NA)
  )


```

### I. Gender

```{r, gender}
#raw_data_cleaned %>% count(q55)

#trans clean

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(q55 = na_if(as.numeric(q55), -99))

#trans indicator
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(trans_id = case_when(
    q55 == 1 ~ 1,
    q55 %in% c(2, 3) ~ 0,  # Conservative approach: counts only self-identified trans as 1
    TRUE ~ NA_real_
  ))


#gender clean
gender_vars <- paste0("q56_", 1:4)

raw_data_cleaned <- raw_data_cleaned %>%
  mutate(across(all_of(gender_vars), ~ na_if(as.numeric(.x), -99)))


#constructing the gender binary
raw_data_cleaned <- raw_data_cleaned %>%
  mutate(gender = case_when(
    q56_2 == 1 ~ 1,  # Selected man
    q56_1 == 1 & (q56_2 != 1 | is.na(q56_2)) ~ 0,  # Woman only or with genderqueer/other
    q56_3 == 1 | q56_4 == 1 ~ 0,  # Genderqueer or other, no man selected
    TRUE ~ NA_real_
  ))



```

###. LAST OF CLEANING - WRITE CSV

```{r}
write_csv(raw_data_cleaned, "data/cleaned/coded_data_may9.csv")
```

# ARCHIVED

```{r}
#| eval: false
#| include: false

getwd()
impacted <- read.csv("/Users/kristinamensik/Library/Mobile Documents/com~apple~CloudDocs/Documents/Duke/2024-2025/902 Legislators Pre-Ananlysis Plan/Prelim Folder/Prelim 3-23/data/impacted.csv")

view(impacted)

# Count unique combinations
impacted_summary <- impacted %>%
  select(been_inc, know_inc, none_inc, been_vict, know_vict, no_vict) %>%
  group_by(across(everything())) %>%
  summarise(count = n(), .groups = "drop") %>%
  arrange(desc(count))

# View the result
view(impacted_summary)

#only incarcerated
sum(
  impacted$been_inc == 1 &
  impacted$no_vict == 1 &
  impacted$know_inc == 0 &
  impacted$none_inc == 0 &
  impacted$been_vict == 0 &
  impacted$know_vict == 0
)

#incarcerated & Victimized
sum(
  impacted$been_inc == 1 &
  impacted$no_vict == 0 &
  impacted$know_inc == 0 &
  impacted$none_inc == 0 &
  impacted$been_vict == 1 &
  impacted$know_vict == 0
)

#incarcerated & Victimized & Know Inc
sum(
  impacted$been_inc == 1 &
  impacted$no_vict == 0 &
  impacted$know_inc == 1 &
  impacted$none_inc == 0 &
  impacted$been_vict == 1 &
  impacted$know_vict == 0
)

#only know incarcerated
sum(
  impacted$been_inc == 0 &
  impacted$no_vict == 1 &
  impacted$know_inc == 1 &
  impacted$none_inc == 0 &
  impacted$been_vict == 0 &
  impacted$know_vict == 0
)

#only vict
sum(
  impacted$been_inc == 0 &
  impacted$no_vict == 0 &
  impacted$know_inc == 0 &
  impacted$none_inc == 1 &
  impacted$been_vict == 1 &
  impacted$know_vict == 0
)

#only know vict
sum(
  impacted$been_inc == 0 &
  impacted$no_vict == 0 &
  impacted$know_inc == 0 &
  impacted$none_inc == 1 &
  impacted$been_vict == 0 &
  impacted$know_vict == 1
)

#know vict, know incarc, been vict
sum(
  impacted$been_inc == 0 &
  impacted$no_vict == 0 &
  impacted$know_inc == 1 &
  impacted$none_inc == 0 &
  impacted$been_vict == 1 &
  impacted$know_vict == 1
)


```
